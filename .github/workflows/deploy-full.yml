# This CI/CD workflow automates the entire process:
# 1. Build: Builds a Docker image and pushes it to Azure Container Registry (ACR).
# 2. Deploy: Connects to a remote VM, sets up the environment, and deploys the new image.

name: Build and Deploy to Development VM

on:
  push:
    branches:
      - dev # Triggers when code is pushed to the 'dev' branch
    paths-ignore:
      - '.github/**'
  workflow_dispatch: # Allows manual triggering

# --- Environment Variables ---
# Central place to manage variables used across jobs.
env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  ACR_NAME: ${{ secrets.ACR_NAME }}
  KEY_VAULT_NAME: ${{ secrets.KEY_VAULT_NAME }}
  IMAGE_NAME: be
  SERVICE_NAME: BE
  VM_USER: root # Or your preferred SSH user
  VM_HOST: ${{ secrets.DEVELOPMENT_BACKEND_VM_HOST }}
  VM_APP_PATH: /app/certainti.ai-product-be # The absolute path to your app on the VM
  COMPOSE_FILE_PATH: /app/docker-compose.yml # The absolute path to your compose file on the VM

jobs:
  # --- BUILD JOB ---
  # This job builds the Docker image and pushes it to ACR.
  build:
    name: Build and Push Image
    runs-on: ubuntu-latest
    environment: development
    outputs:
      image_tag: ${{ steps.image_tag.outputs.tag }} # Make the tag available to other jobs

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set Image Tag
        id: image_tag
        run: echo "tag=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ steps.image_tag.outputs.tag }}

  # --- DEPLOY JOB ---
  # This job runs only after the build job succeeds.
  deploy:
    name: Deploy to VM
    needs: build # Dependency on the 'build' job
    runs-on: ubuntu-latest
    environment: development

    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # This step securely creates the .env file on the runner before copying it.
      - name: Create .env File from Azure Key Vault
        run: |
          echo "Fetching secrets from Azure Key Vault: ${{ env.KEY_VAULT_NAME }}"
          # For each variable, fetch the corresponding secret from Key Vault.
          # The secret name in Key Vault should match the name used here (e.g., "PORT", "CORS-ORIGIN").
          echo "PORT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "PORT" --query value -o tsv)" >> .env
          echo "CORS_ORIGIN=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "CORS-ORIGIN" --query value -o tsv)" >> .env
          echo "ACCESS_TOKEN_SECRET=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "ACCESS-TOKEN-SECRET" --query value -o tsv)" >> .env
          echo "ACCESS_TOKEN_EXPIRY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "ACCESS-TOKEN-EXPIRY" --query value -o tsv)" >> .env
          echo "REFRESH_TOKEN_SECRET=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "REFRESH-TOKEN-SECRET" --query value -o tsv)" >> .env
          echo "REFRESH_TOKEN_EXPIRY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "REFRESH-TOKEN-EXPIRY" --query value -o tsv)" >> .env
          echo "DB_USER=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DB-USER" --query value -o tsv)" >> .env
          echo "DB_PASSWORD=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DB-PASSWORD" --query value -o tsv)" >> .env
          echo "DB_HOST=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DB-HOST" --query value -o tsv)" >> .env
          echo "DB_NAME=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DB-NAME" --query value -o tsv)" >> .env
          echo "DB_PORT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DB-PORT" --query value -o tsv)" >> .env
          echo "OTP_EXPIRY_DAYS=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "OTP-EXPIRY-DAYS" --query value -o tsv)" >> .env
          echo "OTP_EXPIRY_HOURS=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "OTP-EXPIRY-HOURS" --query value -o tsv)" >> .env
          echo "OTP_EXPIRY_MINUTES=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "OTP-EXPIRY-MINUTES" --query value -o tsv)" >> .env
          echo "OTP_CIPHER_KEY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "OTP-CIPHER-KEY" --query value -o tsv)" >> .env
          echo "OTP_LENGTH=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "OTP-LENGTH" --query value -o tsv)" >> .env
          echo "OTP_ALPHANUMERIC=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "OTP-ALPHANUMERIC" --query value -o tsv)" >> .env
          echo "AZURE_STORAGE_CONNECTION_STRING=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "AZURE-STORAGE-CONNECTION-STRING" --query value -o tsv)" >> .env
          echo "CONTAINER_NAME=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "CONTAINER-NAME" --query value -o tsv)" >> .env
          echo "CLIENT_ID=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "CLIENT-ID" --query value -o tsv)" >> .env
          echo "CLIENT_SECRET=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "CLIENT-SECRET" --query value -o tsv)" >> .env
          echo "USER_NAME=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "USER-NAME" --query value -o tsv)" >> .env
          echo "PASSWORD=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "PASSWORD" --query value -o tsv)" >> .env
          echo "TENANT_ID=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "TENANT-ID" --query value -o tsv)" >> .env
          echo "WEBHOOK_UPLOAD_URL=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "WEBHOOK-UPLOAD-URL" --query value -o tsv)" >> .env
          echo "WEBHOOK_REUPLOAD_URL=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "WEBHOOK-REUPLOAD-URL" --query value -o tsv)" >> .env
          echo "SURVEY_ACTIVE_DAYS=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-ACTIVE-DAYS" --query value -o tsv)" >> .env
          echo "SURVEY_DUE_DATE_OFFSET=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-DUE-DATE-OFFSET" --query value -o tsv)" >> .env
          echo "SURVEY_LINK=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-LINK" --query value -o tsv)" >> .env
          echo "SURVEY_CIPHER_KEY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-CIPHER-KEY" --query value -o tsv)" >> .env
          echo "SURVEY_SUPPORT_MAIL=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-SUPPORT-MAIL" --query value -o tsv)" >> .env
          echo "SURVEY_CONFIRM_MAIL=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-CONFIRM-MAIL" --query value -o tsv)" >> .env
          echo "SURVEY_COMPANY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SURVEY-COMPANY" --query value -o tsv)" >> .env
          echo "INTERACTIONS_LINK=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "INTERACTIONS-LINK" --query value -o tsv)" >> .env
          echo "INTERACTIONS_CIPHER_KEY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "INTERACTIONS-CIPHER-KEY" --query value -o tsv)" >> .env
          echo "AI_GENERATE_SUMMARY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "AI-GENERATE-SUMMARY" --query value -o tsv)" >> .env
          echo "AI_GENERATE_ASSESSMENT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "AI-GENERATE-ASSESSMENT" --query value -o tsv)" >> .env
          echo "USER_ID_KEY=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "USER-ID-KEY" --query value -o tsv)" >> .env
          echo "KEY_PATH=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "KEY-PATH" --query value -o tsv)" >> .env
          echo "CERT_PATH=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "CERT-PATH" --query value -o tsv)" >> .env
          echo "SESSION_TIMEOUT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SESSION-TIMEOUT" --query value -o tsv)" >> .env
          echo "SESSION_CLEANUP_TIMEOUT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "SESSION-CLEANUP-TIMEOUT" --query value -o tsv)" >> .env
          echo "ACTIVE_SURVEY_TEMPLATE=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "ACTIVE-SURVEY-TEMPLATE" --query value -o tsv)" >> .env
          echo "DOCUMENT_UPLOAD_SIZE_LIMIT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DOCUMENT-UPLOAD-SIZE-LIMIT" --query value -o tsv)" >> .env
          echo "DOCUMENT_UPLOAD_COUNT_LIMIT=$(az keyvault secret show --vault-name "${{ env.KEY_VAULT_NAME }}" --name "DOCUMENT-UPLOAD-COUNT-LIMIT" --query value -o tsv)" >> .env

          echo ".env file created successfully."

      - name: Setup SSH and Deploy to VM
        run: |
          # 1. Setup SSH Key
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ env.VM_HOST }} >> ~/.ssh/known_hosts
          
          # 2. Securely copy the .env file to the VM's temporary directory
          echo "Copying .env file to VM..."
          scp -o StrictHostKeyChecking=no .env ${{ env.VM_USER }}@${{ env.VM_HOST }}:/tmp/.env
          
          # 3. SSH into the VM and run deployment commands
          echo "Connecting to VM to start deployment..."
          ssh -o StrictHostKeyChecking=no ${{ env.VM_USER }}@${{ env.VM_HOST }} << 'EOF'
            # Use sudo for privileged commands
            sudo -s
            
            # --- ADVANCED SCRIPTING ---
            # This command ensures that the script will exit immediately if any command fails.
            set -e
            
            echo "--- Starting Deployment on VM ---"
            
            # Move the .env file from /tmp to the application directory
            echo "Moving .env file to ${{ env.VM_APP_PATH }}/.env"
            mv /tmp/.env ${{ env.VM_APP_PATH }}/.env
            
            # Define variables for the deployment using the tag from the build job
            FULL_IMAGE_NAME="${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build.outputs.image_tag }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE_PATH }}"
            SERVICE_NAME="${{ env.SERVICE_NAME }}"
            
            # Update the docker-compose file to use the new image from ACR
            echo "Updating docker-compose file: ${COMPOSE_FILE}"
            sed -i "/^\s*${SERVICE_NAME}:/,/image:/s|image: .*|image: ${FULL_IMAGE_NAME}|" ${COMPOSE_FILE}
            
            # Log in to ACR from the VM (requires Azure CLI on the VM)
            echo "Logging into ACR from VM..."
            az acr login --name ${{ env.ACR_NAME }}
            
            # ** MORE ROBUST DEPLOYMENT STEPS **
            # 1. Explicitly pull the new image from ACR first
            echo "Pulling new image: ${FULL_IMAGE_NAME}"
            docker-compose -f ${COMPOSE_FILE} pull ${SERVICE_NAME}

            # 2. Stop the currently running service (if it exists)
            echo "Stopping current service..."
            docker-compose -f ${COMPOSE_FILE} stop ${SERVICE_NAME}

            # 3. Remove the stopped container
            echo "Removing old container..."
            docker-compose -f ${COMPOSE_FILE} rm -f ${SERVICE_NAME}

            # 4. Start a new container from the newly pulled image
            echo "Starting new container for service: ${SERVICE_NAME}"
            docker-compose -f ${COMPOSE_FILE} up -d --no-deps ${SERVICE_NAME}
            
            # Clean up old, unused Docker images
            echo "Cleaning up old Docker images..."
            docker image prune -af
            
            echo "--- ✅ Deployment on VM Complete ---"
            exit
          EOF
